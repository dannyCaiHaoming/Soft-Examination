# 1 软件开发模型

## 1.1 瀑布模型
![](/5.软件工程/img/瀑布模型.png)

瀑布模型是将软件生存周期中各个活动规定为依照`线性`顺序连接的若干阶段模型。包括需求分析、设计、编码、测试、运行和维护。

**瀑布模型以`文档`作为驱动，适合于软件需求很明确的软件项目的模型**
**容易理解、成本低、强调开发阶段性计划、需求调查和产品测试**

## 1.2 V模型

V模型是瀑布模型的一个变体。描述了质量保证活动和沟通、建模相关活动以及早期构建相关活动之间的关系（比起瀑布模型，V模型开头加了点东西）

## 1.3 增量模型

增量模型融合了`瀑布模型`的基本成分和`原型`实现的迭代特征。它假设可以将需求分段为一系列增量产品，每一增量可以分别开发。当使用增量模型时，`第一个增量往往是核心产品`，客户对每个增量的使用和评估都可以作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终完善产品。<br>
增量模型强调`每一个增量均发布一个可操作的产品`。

## 1.4 演化模型

![演化模型](/5.软件工程/img/演化模型.png)

### 1.4.1 原型模型

螺旋模型基于原型模式，原型模式也是一个闭环。。<br>
开始于沟通，目的是定义软件的总体目标、识别需求，然后快速指定原型开发计划，然后构建原型之后交付用户，得到反馈后继续下一轮进行开发。<br>
原型模型比较适合于用户需求不清、需求经常变化的情况。当系统需求不大也不是太复杂的时候，采用原型模型比较好。

### 1.4.2 螺旋模型

![螺旋模型](/5.软件工程/img/螺旋模型.png)

螺旋模型将`瀑布模型`和`原型`结合起来,加入了两种模型忽略的风险分析。<br>
螺旋模型强调`风险分析`，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。适用于`庞大复杂且高风险的系统`。也可用于`用户需求不清，需求经常变化`的情况。

### 1.4.3 喷泉模型

喷泉模型是一种以`用户需求为动力、以对象作为驱动的模型`，适合于`面向对象`的开发方法。喷泉模型使得开发过程中具`有迭代性和无间隙性`（开发活动中间不存在明显边界，允许开发活动交叉迭代进行。）

### 1.4.4 构建组装模型

![构建组装模型](/5.软件工程/img/构建组装模型.png)

使用预先包装的构建来构造应用系统。

### 1.4.5 形式化方法模型

建立在严格数学基础上的一种软件开发方法，主要活动是生成计算机软件形式化的`数学规则说明`。

## 1.7 敏捷开发方法

![](/5.软件工程/img/敏捷开发方法.png)

1. 极限编程（XP）：是一种轻量型（敏捷）、高效、低风险、柔性、可预测的科学的软件开发方式。主要就是由上图中的4大价值观、5大原则、12个最佳实践组成。
   1. 四大价值观（勇反沟简）
2. 水晶法（Crystal）：水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论，认为人对软件质量有重要的影响。因此随着项目质量和人员质量的提升，项目和过程的质量也随之提升。
3. 并列争球法（Scrum）：使用迭代的方法，其中，把没30天一次迭代成为一次冲刺，并按需求的优先级别来实现产品。
   1. 步骤为：产品backlog----Sprint计划会议-----Sprint backlog -----Sprint

# 2 软件开发方法

![软件开发方法](/5.软件工程/img/软件开发方法.png)

1. 结构化方法：由结构化分析、结构化设计、结构化程序设计构成，它是一种面向数据流的开发方法。总的指导思想是自顶向下、逐层分解，基本原则是功能的分解和抽象。特别适合于数据处理领域的问题，但是不适合解决大规模、特别复杂的项目，且难以适应需求的变化。

2. Jackson方法：面向数据结构的开发方法。以数据结构为驱动，适合于小规模的项目。

3. 原型化方法： 适合于用户需求不清、业务理论不稳定、需求经常变化的情况。

4. 面向对象开发方法： 包括面向对象分析、面向对象设计和面向对象实现，采用同一建模语言（UML）

# 3 软件需求分析

- 功能需求
- 性能需求
- 用户或人的因素
- 环境需求
- 界面需求
- 文档需求
- 数据需求
- 资源使用需求
- 安全保密需求
- 可靠性需求
- 软件成本消耗与开发进度需求
- 其他非功能需求：如开发模式，质量标准，验收标准，里程碑和评审

# 4 软件设计（高内聚、低耦合、提高模块的独立性）

![软件设计](/5.软件工程/img/软件设计.png)

## 4.1 内聚

- 功能内聚：最强，值模块内所有元素完成一个功能，缺一不可
- 顺序内聚：模块中各个处理元素跟同一个功能相关，按顺序执行，
- 通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集
- 过程内聚：把需要同时执行的动作组合在一起，包含的任务并非一次过顺序执行完
- 逻辑内聚：模块内执行的逻辑有逻辑相似的功能
- 偶然内聚：模块内各处理元素没有任何联系

顺序内聚中是数据流从一个处理单元流到另一个处理单元，而过程内聚是控制流从一个动作流向另一个动作。

## 4.2 耦合

- 无直接耦合：两个模块之间没有直接的关系，他们之间的联系由主模块控制
- 数据耦合：两个模块之间有调用关系，只是数据传递（简单）
- 标记耦合：传递数据结构，传递类等等的吧
- 控制耦合：传递控制变量来控制被调用模块选择执行哪个功能
- 外部耦合：软件外的环境联结（IO设备之类）
- 公共耦合：都访问一个公共数据
- 内容耦合：一个模块使用另一个模块的内容

# 5 软件测试

## 5.1 测试原则与类型

![测试原则与类型](/5.软件工程/img/测试原则与类型.png)

### 5.1.1 单元测试

- 模块接口
  - 保证输入输出正确
  - 保证输入的参数个数、属性、单位一致
  - 调用其他模块时保证实际参数和形式参数个数属性单位一致
  - 调用时顺序时候一致
  - 全局变量在各模块中的定义和语法是否一致
  - 输入是否改变了形式参数
- 局部数据结构
- 重要的执行路径
- 出错处理

## 5.2 测试用例设计

![测试用例设计](/5.软件工程/img/测试用例设计.png)

## 5.3 测试阶段

![测试阶段](/5.软件工程/img/测试阶段.png)

## 5.4 McCabe复杂度

![McCabe复杂度](/5.软件工程/img/McCabe复杂度.png)

# 6 软件维护

![软件维护](/5.软件工程/img/软件维护.png)

1. 改正性维护：改正在系统开发阶段已经发生而系统测试阶段未发现的问题 -- 改bug
2. 适应性维护：使应用适应信息技术变化、企业外部环境、管理需求变化而进行的修改。例如IE版本升级适配 -- 适应IE 
3. 完善性维护：为扩充功能和改善性能而进行的修改，增加和修改需求呗  -- 完求
4. 预防性维护：为了改进应用可靠性和可维护性，适应未来的软硬件环境的变化，应主动增加预防性的新的功能  -- 预表

# 7 软件过程改进---能力成熟度模型集成（CMMI）

![软件过程](/5.软件工程/img/软件过程.png)

## 7.1 阶段式模型

1. 初始的：过程不可预测且缺乏控制。
2. 已管理：过程为项目服务。
3. 已定义：过程为组织服务。
4. 定量管理：过程已度量和控制。
5. 优化的：集中于过程改进

## 7.2 连续式模型

1. CLO（未完成的）：过程域未执行或未得到CL1中农定义的所有目标
2. CL1（已执行的）：共性目标是将可标识的输入工作产品转换成可标识的输出工作产品。实现过程域支持
3. CL2（已管理的）：共性目标集中于已管理的过程制度化
4. CL3（已定义）：共性目标集中于已定义的制度化
5. CL4（定量管理的）：集中可定量管理过程的制度化
6. CL5（优化的）：使用量化首段改变和优化过程域，以满足客户改变

能力成熟度模型大体都一样~ 连续就多了一个0，为满足1的就叫0，即是项目流产。

# 8 软件项目管理

![软件项目管理](/5.软件工程/img/软件项目管理.png)

## 8.1 时间管理（Gantt图、PERT图）

1. Gantt图：能够清晰描述每个任务开始时间、结束时间、任务的进展情况及各个`任务之间的并行性`.但不能清晰反映任务之间的`依赖关系`.难以确定关键地方
2. PERT图：不仅给出开始时间，结束时间，完成任务所需时间，还给出任务之间的依赖关系。但是不能反映并行关系。

## 8.2 风险管理

![风险管理](/5.软件工程/img/风险管理.png)

一般认为软件风险包含两个特性：`不确定性`和`损失`，不确定性即指风险可能发生也可能不发生。评估风险的影响，如果风险真的发生，有3个因素可能会影响风险所产生的后果，即风险的本质、范围和时间。如果风险可以预测，可以避免其发生，有些风险可以预测但无法避免。风险控制的目的是辅助项目组建立处理风险的策略。

 ### 8.2.1 风险识别
 风险识别试图系统化地指出对项目计划的威胁。 --- 建立风险识别条目检查表。


 ### 8.2.2 风险预测、风险估计
 - 建立度量
 - 描述后果
 - 估算风险影响

### 8.2.3  风险评估
评估参照表


### 8.2.4 风险控制

# 9 软件质量保证

## 9.1 功能性

1. 适合性
2. 准确性
3. 互用性
4. 依从性
5. 安全性
   

## 9.2 可靠性

1. 成熟性
2. 容错性
3. 已恢复性

## 9.3 易使用性

1. 易理解性
2. 易学性
3. 易操作性
   
## 9.4 效率
1. 时间特性
2. 资源特性

## 9.5 可维护性

1. 易分析性
2. 易改变性
3. 易测试性
4. 稳定性

## 9.6 可移植性

1. 适应性
2. 一致性
3. 易安装性
4. 易替换性
